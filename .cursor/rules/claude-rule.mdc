---
description: Senior Guidelines Í∏∞Î∞ò
globs: ["**/*.js", "**/*.jsx", "**/*.ts", "**/*.tsx"]
alwaysApply: true
---



## Core Philosophy

1. **Simplicity & Readability**: Code must be easy to read; complexity is intentionally isolated.
2. **RSC-First Approach**: Leverage Server Components (RSC) by default to optimize bundle size; delegate only interactive parts to the client.
3. **Type-Safe Everything**: Combine Zod and TypeScript to catch errors before runtime.
4. **Functional & Pragmatic**: Favor immutability and pure functions without compromising practical productivity.
5. **Fail Fast & Gracefully**: Detect errors early (Zod) and present them gracefully to users (Error Boundary).
6. **Security by Default**: RLS policies, server-side auth validation, and environment variable protection are non-negotiable.

---

## üèóÔ∏è 1. Architecture: RSC & Client Components

Instead of making every component a client component, adopt the strategy of **fetching data on the server and handling interactions on the client**.

- **Server Components (Default)**: Data fetching, security-critical logic, SEO-sensitive layouts.
- **Client Components (`'use client'`)**: `useState`, `useEffect`, browser APIs, complex user interactions (Framer Motion, Shadcn UI, etc.).
- **Server Actions**: Handle form submissions and data mutations directly without API Routes.

```typescript
// ‚úÖ Structure Example
// app/posts/page.tsx (Server Component)
export default async function PostsPage() {
  const posts = await getPosts() // Direct data fetching on the server
  return <PostList posts={posts} />
}

// components/PostList.tsx (Client Component)
'use client'
export function PostList({ posts }) {
  const [filter, setFilter] = useState('')
  // ... interactive logic
}
```

### Server Actions (Stable)

Server Actions are stable in Next.js 15. Prefer Server Actions over API Routes.

```typescript
// app/actions/posts.ts
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

export async function createPost(formData: FormData): Promise<Result<Post, string>> {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) return { success: false, error: 'Authentication required.' }

  const validated = postSchema.safeParse(Object.fromEntries(formData))
  if (!validated.success) return { success: false, error: 'Invalid input.' }

  const { data, error } = await supabase
    .from('posts')
    .insert({ ...validated.data, user_id: user.id })
    .select()
    .single()

  if (error) return { success: false, error: 'Failed to create post.' }

  revalidatePath('/posts')
  return { success: true, data }
}
```

### Partial Prerendering (PPR)

Combine a static shell with dynamic content to maximize initial load speed.

```typescript
// app/dashboard/page.tsx
import { Suspense } from 'react'
import { DashboardShell } from '@/components/dashboard-shell'
import { DynamicStats } from '@/components/dynamic-stats'

export default function DashboardPage() {
  return (
    <DashboardShell>
      <Suspense fallback={<StatsSkeleton />}>
        <DynamicStats />
      </Suspense>
    </DashboardShell>
  )
}
```

---

## üõ†Ô∏è 2. Supabase Workflow: SSR, Auth & Migration

### @supabase/ssr Package (Required)

`@supabase/auth-helpers-nextjs` is deprecated. Always use the **`@supabase/ssr`** package.

```bash
npm install @supabase/supabase-js @supabase/ssr
```

### Supabase Client Setup

```typescript
// lib/supabase/client.ts (Browser Client)
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

// lib/supabase/server.ts (Server Client)
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Ignored when called from a Server Component.
            // Middleware handles session refresh.
          }
        },
      },
    }
  )
}
```

### Middleware (Session Refresh Required)

Since Server Components cannot write cookies, the middleware must refresh session tokens.

```typescript
// lib/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            request.cookies.set(name, value)
          )
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // ‚ö†Ô∏è Always use getUser() ‚Äî getSession() is NOT safe on the server
  await supabase.auth.getUser()

  return supabaseResponse
}

// middleware.ts (project root)
import { updateSession } from '@/lib/supabase/middleware'
import { type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

### Auth Validation Rules

```typescript
// ‚ö†Ô∏è NEVER use getSession() for server-side auth
// getSession() does not verify the cookie signature and can be spoofed

// ‚úÖ Always use getUser() on the server
const { data: { user } } = await supabase.auth.getUser()

// ‚ùå Do NOT use getSession() on the server
const { data: { session } } = await supabase.auth.getSession() // UNSAFE!
```

### Migration Workflow

1. **Local Development**: Run the local Docker DB via `supabase start`.
2. **Migration First**: All schema changes are created as files via `supabase migration new [name]`.
3. **Type Generation**: Always update types after schema changes.

```bash
npm run supabase:gen
```

### RLS (Row Level Security) Required

Enable RLS on every table and configure appropriate policies.

```sql
-- ‚úÖ Enable RLS on all tables
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

-- Read policy: only team members can view
CREATE POLICY "Team members can view posts"
  ON posts FOR SELECT
  USING (
    team_id IN (
      SELECT team_id FROM team_members
      WHERE user_id = auth.uid()
    )
  );

-- Write policy: only the author can update
CREATE POLICY "Authors can update own posts"
  ON posts FOR UPDATE
  USING (user_id = auth.uid());
```

---

## ‚ö†Ô∏è 3. Error Handling: Result Pattern & UX

Instead of throwing exceptions, use the **Result Pattern** that explicitly returns success or failure.

### Global Result Type

```typescript
// src/types/common.types.ts
export type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E }
```

### Server Action Example

```typescript
export async function updateProfile(formData: FormData): Promise<Result<User, string>> {
  try {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return { success: false, error: 'Authentication required.' }

    const validated = profileSchema.safeParse(Object.fromEntries(formData))
    if (!validated.success) return { success: false, error: 'Invalid input.' }

    const { data, error } = await supabase
      .from('profiles')
      .update(validated.data)
      .eq('id', user.id)
      .select()
      .single()

    if (error) return { success: false, error: 'Failed to update profile.' }

    revalidatePath('/profile')
    return { success: true, data }
  } catch (e) {
    return { success: false, error: 'A server error occurred.' }
  }
}
```

---

## üîÑ 4. State Management & Optimistic UI

### Server State (React Query)

Use React Query for data fetching and actively employ **Optimistic Updates** for a better user experience.

```typescript
// features/comments/hooks/useCreateComment.ts
export function useCreateComment() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: createComment,
    onMutate: async (newComment) => {
      await queryClient.cancelQueries({ queryKey: ['comments'] })
      const previousComments = queryClient.getQueryData(['comments'])

      // Optimistically update the cache
      queryClient.setQueryData(['comments'], (old) => [...old, newComment])

      return { previousComments }
    },
    onError: (err, newComment, context) => {
      queryClient.setQueryData(['comments'], context.previousComments)
      toast.error('Failed to create comment.')
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['comments'] })
    }
  })
}
```

### Client-Only UI State (Zustand)

```typescript
// stores/ui.store.ts
// Zustand is used ONLY for UI state (sidebar toggle, modals, etc.)
import { create } from 'zustand'

interface UIStore {
  sidebarOpen: boolean
  toggleSidebar: () => void
}

export const useUIStore = create<UIStore>((set) => ({
  sidebarOpen: false,
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
}))
```

---

## üö¶ 5. Loading & Error Boundaries

Use the built-in features of the Next.js App Router for declarative UX management.

- **`loading.tsx`**: Provides skeleton UI for pages while data is being fetched.
- **`error.tsx`**: Offers recovery options (Try Again) for unexpected runtime errors.
- **`not-found.tsx`**: Provides a custom 404 page for non-existent resources.
- **`Suspense`**: Used for component-level loading instead of full-page loading.

```typescript
// app/dashboard/error.tsx
'use client'

export default function DashboardError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div className="flex flex-col items-center gap-4 p-8">
      <h2 className="text-lg font-semibold">Something went wrong</h2>
      <p className="text-muted-foreground">{error.message}</p>
      <Button onClick={() => reset()}>Try Again</Button>
    </div>
  )
}
```

---

## üé® 6. Standard UI Guidelines

- **Shadcn UI**: Primary UI component library. Customize as needed.
- **Tailwind CSS**: Utility-first styling. Use CSS Modules only for complex animations.
- **Icons**: `lucide-react` as the standard icon library.
- **Placeholders**: Use `https://picsum.photos/` for image testing.
- **Toast Notifications**: Use `sonner` for user feedback.
- **Dark Mode**: Integrate with system preferences via `next-themes`.

---

## üìù 7. Code Style (Standard.js + TS)

- **No Semicolons**: Do not use semicolons. (Watch out for ASI edge cases)
- **Single Quotes**: Use single quotes for strings.
- **Indentation**: 2-space indent.
- **Naming**:
  - Features: `kebab-case` (e.g., `auth-wizard`)
  - Components: `PascalCase`
  - Functions/Variables: `camelCase`
  - Environment Variables: `UPPER_SNAKE_CASE`
  - Types/Interfaces: `PascalCase` (no `I` prefix)
- **Import Order**:
  1. React / Next.js
  2. External libraries
  3. Internal modules (`@/`)
  4. Types
- **ESLint Config**:

```json
{
  "rules": {
    "semi": ["error", "never"],
    "no-unexpected-multiline": "error"
  }
}
```

> **Note**: `next lint` has been deprecated since Next.js 15.5. Use the ESLint CLI directly.
> ```bash
> npx @next/codemod@canary upgrade latest  # automated migration
> ```

---

## üß™ 8. Testing Strategy

### Testing Tools

| Level | Tool | Target |
|-------|------|--------|
| Unit | **Vitest** + React Testing Library | Client Components, utility functions, hooks |
| E2E | **Playwright** | Full user flows, Server Components |

### Installation & Setup

```bash
# Unit Tests
npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths

# E2E Tests
npm init playwright@latest
```

```typescript
// vitest.config.mts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import tsconfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  plugins: [tsconfigPaths(), react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    include: ['**/*.test.{ts,tsx}'],
  },
})
```

### Test Writing Rules

```typescript
// ‚úÖ Unit Test: Client Component
import { expect, test } from 'vitest'
import { render, screen } from '@testing-library/react'
import { PostCard } from '@/features/posts/components/PostCard'

test('PostCard renders title correctly', () => {
  render(<PostCard title="Test Post" />)
  expect(screen.getByText('Test Post')).toBeDefined()
})

// ‚úÖ E2E Test: Full Flow (Playwright)
import { test, expect } from '@playwright/test'

test('user can create a new post', async ({ page }) => {
  await page.goto('/dashboard')
  await page.click('text=New Post')
  await page.fill('[name="title"]', 'Test Title')
  await page.click('text=Save')
  await expect(page.locator('text=Test Title')).toBeVisible()
})
```

### Test File Structure

```
tests/
  setup.ts              # Vitest global setup
  e2e/                  # Playwright E2E tests
    auth.spec.ts
    dashboard.spec.ts
src/
  features/
    posts/
      components/
        PostCard.test.tsx   # Unit test (colocated)
      hooks/
        useCreatePost.test.ts
```

> **Note**: Async Server Components are not yet supported by Vitest. Use Playwright E2E tests to verify async components.

---

## üîí 9. Security

### Environment Variable Management

```typescript
// lib/env.ts ‚Äî Environment variable validation with Zod
import { z } from 'zod'

const envSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),
  // Client-exposed variables MUST have the NEXT_PUBLIC_ prefix
})

export const env = envSchema.parse(process.env)
```

### Security Checklist

- **RLS Required**: Enable Row Level Security on every Supabase table. Data is inaccessible without policies.
- **Server Auth**: Use only `supabase.auth.getUser()`. Never use `getSession()` on the server.
- **Service Role Key**: Never expose to the client. Use only in Server Actions or API Routes.
- **Input Validation**: Validate all user input with Zod schemas.
- **CSRF**: Server Actions are automatically protected by Next.js. API Routes require separate handling.
- **Rate Limiting**: Apply rate limiting to critical APIs (via Supabase Edge Functions or middleware).

### Auth Protection Pattern

```typescript
// app/(protected)/layout.tsx
import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'

export default async function ProtectedLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    redirect('/login')
  }

  return <>{children}</>
}
```

---

## üöÄ 10. Deployment & CI/CD

### Vercel Deployment

```bash
# next.config.ts
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    typedRoutes: true,  // Stable since Next.js 15.5
  },
}

export default nextConfig
```

### Environment Variable Configuration

| Environment | Description |
|-------------|-------------|
| `development` | `.env.local` (local only, excluded from Git) |
| `preview` | Vercel Preview environment variables |
| `production` | Vercel Production environment variables |

### CI/CD Pipeline (GitHub Actions)

```yaml
# .github/workflows/ci.yml
name: CI
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm ci
      - run: npx eslint . --max-warnings 0
      - run: npm run build
      - run: npx vitest run
      - run: npx playwright install --with-deps
      - run: npx playwright test

  type-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm ci
      - run: npx tsc --noEmit

  supabase-migration:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - uses: supabase/setup-cli@v1
      - run: supabase db push
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
```

### Branch Strategy

- `main`: Production (auto-deploy)
- `dev`: Development (Preview deploy)
- `feature/*`: Feature branches (PR ‚Üí merge into dev)

---

## üìÇ 11. Updated Directory Structure

```
src/
  app/                    # Next.js App Router (RSC by default)
    (auth)/               # Auth-related Route Group
      login/
      signup/
    (protected)/          # Auth-required Route Group
      dashboard/
      settings/
    api/                  # API Routes (when needed)
    actions/              # Shared Server Actions
    layout.tsx
    page.tsx
    loading.tsx           # Global Loading
    error.tsx             # Global Error Boundary
    not-found.tsx         # Global 404

  features/               # Feature-based modules (self-contained)
    [feature-name]/
      components/         # Mark 'use client' when needed
        FeatureCard.tsx
        FeatureCard.test.tsx  # Colocated unit test
      hooks/
      actions.ts          # Feature-specific Server Actions
      api.ts              # React Query fetchers
      types.ts
      schema.ts           # Zod validation schemas

  components/
    ui/                   # Shadcn UI
    common/               # Shared presentational components

  lib/
    supabase/
      client.ts           # Browser client (@supabase/ssr)
      server.ts           # Server client (@supabase/ssr)
      middleware.ts        # Session refresh
    env.ts                # Zod Env Validation
    utils.ts              # cn() and shared utilities

  stores/                 # Zustand (UI State Only!)
  types/
    database.types.ts     # Supabase Generated
    common.types.ts       # Result, Pagination, and shared types

tests/
  setup.ts                # Vitest setup
  e2e/                    # Playwright E2E tests

middleware.ts             # Next.js Middleware (Supabase session refresh)
```

---

## ‚úÖ Final Checklist

1. [ ] **RSC vs Client**: Are non-interactive pages/components Server Components?
2. [ ] **Zod Env**: Have new environment variables been registered in `lib/env.ts`?
3. [ ] **Supabase Migration**: Have DB schema changes been created as migration files?
4. [ ] **RLS Policy**: Is RLS enabled on new tables with appropriate policies?
5. [ ] **Auth**: Is `getUser()` used on the server? (`getSession()` is forbidden)
6. [ ] **Error Handling**: Is the `Result` pattern applied in Server Actions?
7. [ ] **Optimistic UI**: Are optimistic updates applied for key actions (likes, comments, etc.)?
8. [ ] **Validation**: Is Zod schema validation applied to all user inputs?
9. [ ] **Tests**: Have Unit/E2E tests been written for key features?
10. [ ] **No Semi**: Is the code free of unnecessary semicolons?
11. [ ] **Korean UTF-8**: Has Korean text been verified to render correctly?
12. [ ] **Security Review**: Is the Service Role Key confirmed not exposed to the client?

---

## üìã Changelog (v2.0 ‚Üí v3.0)

### New Sections
- **¬ß8 Testing Strategy**: Added Vitest + Playwright testing strategy
- **¬ß9 Security**: Added RLS enforcement, auth validation, env protection, and security checklist
- **¬ß10 Deployment & CI/CD**: Added Vercel deployment, GitHub Actions pipeline, and branch strategy

### Major Changes
- **¬ß1 Architecture**: Added Server Actions (stable) section and Partial Prerendering (PPR) pattern
- **¬ß2 Supabase**: Full migration to `@supabase/ssr` package; detailed cookie-based auth setup; added middleware session refresh pattern; added `getUser()` vs `getSession()` security warning; enforced RLS policies
- **¬ß5 Loading**: Added `not-found.tsx` and `error.tsx` code examples
- **¬ß6 UI**: Added `sonner` (toast) and `next-themes` (dark mode)
- **¬ß7 Code Style**: Added import order rules and type naming conventions; noted `next lint` deprecation
- **¬ß11 Directory**: Added `(protected)/` Route Group, `schema.ts`, `actions.ts`; added `tests/` directory
- **Final Checklist**: Expanded from 7 to 12 items (RLS, Auth, Validation, Tests, Security)

---

**This guide is written for Next.js 15.x, @supabase/ssr, and Turbopack (as of 2025). All code must adhere to these rules. Consult the team before making any exceptions.**